import fexproto as fx
tokens = fx.tokenize(r'''
(+ (+ 1 1) (+ 2 3))
(+ 1 4)
(($vau (e (a b)) (+ (eval e a) (eval e b))) (+ 1 3) (+ 2 4))
((wrap (unwrap car)) (($vau (e a) a) a b c))
($define! std ($vau (#ignore name)
    (eval (make-standard-environment) (car name))))
((std $car) (a b c))
($define! (temp1 (#ignore temp2)) ($car ((a (b c)))))
temp1
temp2
($if (eq? ($car (a)) ($car (a))) 1 0)
($if (eq? #f (eq? #ignore #ignore)) 1 0)
(eq? 3 (+ 1 2))
(eq? 3.5 (+ 3 0.5))
(eq? "hi" "hi")
(cons 4 6)
($define! reverse
        ($lambda (a)
                ($define! reverse-tail
                        ($lambda (in out)
                            ($if (eq? in ())
                                out
                                (reverse-tail (cdr in) (cons (car in) out)))))
                (reverse-tail a ())))
((unwrap reverse) (3 2 1))
((unwrap pair?) (1 2))
(call/cc ($lambda (cont) ((continuation->applicative cont) 1)))
(eq? #\a #\x61)
(<=? 1 2)
(call/cc ($lambda (cont)
    ((continuation->applicative
            (extend-continuation cont ($lambda (x) (+ x 1))))
        1)))
(($lambda ()
    ($define! p (cons 1 2))
    (set-car! p 3)
    (set-cdr! p 4)
    ($if (eq? 3 (car p)) (eq? 4 (cdr p)) #f)))
(list->string (string->list "abc"))
(number? 3)
((unwrap symbol?) abc)
(eq? (string->symbol ((unwrap symbol->string) abc)) ((unwrap list) . abc))
(environment? (get-current-environment))
(call/cc ($lambda (cc) (continuation? cc)))
(char? #\a)
(string? "abc")
(eval (make-standard-environment) (list $sequence (list load "test_fexproto.lisp") ((unwrap list) . variable) 1))
(eq? #t ($binds? (get-current-environment) car))
(eq? #f ($binds? (get-current-environment) racecar))
(($lambda ()
    ($define! $and? ($vau (dyn args)
        ($cond
            ((null? args) #t)
            ((eval dyn (car args))
                (apply (wrap $and?) (cdr args) dyn))
            (#t #f))))
    ($define! (e1 p1? d1) (make-encapsulation-type))
    ($define! (e2 p2? d2) (make-encapsulation-type))
    ($define! obj1 (e1 make-encapsulation-type))
    ($and?
        (p1? obj1)
        (eq? #f (p2? obj1))
        (eq? (d1 obj1) make-encapsulation-type))))
(($lambda ()
    ($define! $and? ($vau (dyn args)
        ($cond
            ((null? args) #t)
            ((eval dyn (car args))
                (apply (wrap $and?) (cdr args) dyn))
            (#t #f))))
    ($define! (b1 a1) (make-keyed-dynamic-variable))
    ($define! (b2 a2) (make-keyed-dynamic-variable))
    (b1 123 ($lambda ()
        (b2 456 ($lambda ()
            (b1 789 ($lambda ()
                ($and?
                    (eq? (a1) 789)
                    (eq? (a2) 456))))))))))
(($lambda ()
    ($define! $and? ($vau (dyn args)
        ($cond
            ((null? args) #t)
            ((eval dyn (car args))
                (apply (wrap $and?) (cdr args) dyn))
            (#t #f))))
    ($define! (b1 a1) (make-keyed-static-variable))
    ($define! (b2 a2) (make-keyed-static-variable))
    ($define! e (b1 789 (b2 456 (b1 123 (make-environment)))))
    ($and?
        (eq? (eval e (list a1)) 789)
        (eq? (eval e (list a2)) 456))))
''')
exprs = fx.parse(tokens, filename="\x00test")
env = fx._make_standard_environment()
for expr, expected in zip(exprs, [7, 5, 10, "a", None, "a", None, "a", "c", 1, 0, True, True, True, fx.Pair(4, 6), None, fx.Pair(1, fx.Pair(2, fx.Pair(3, ()))), True, fx.Pair(1, ()), True, True, 2, True, b'abc', True, True, True, True, True, True, True, 1, True, True, True, True, True]):
    actual = fx.f_eval(env, expr)
    if expected is ...:
        continue
    assert actual == expected, f'{actual} != {expected} (expr={expr})'
